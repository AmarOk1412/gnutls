/* nettle, low-level cryptographics library
 *
 * Copyright (C) 2013 Red Hat
 * Copyright (C) 2008  Free Software Foundation, Inc.
 *  
 * The nettle library is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * Libgcrypt is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

/* This is a known-answer test for the DRBG-AES. The test vectors
 * and test structures are taken from libgcrypt's DRBG-AES implementation.
 * We differ however, in the fact we always discard an AES block when
 * the key is changed. That's why the 2nd and 3rd test vectors differ
 * from libgcrypt's vectors by 1.
 */

#include <config.h>
#include <drbg-aes.h>
#include <string.h>

struct self_test_st {
	const uint8_t key[16];
	const uint8_t dt[16];
	const uint8_t v[16];
	const uint8_t r[3][16];
};

struct priv_st {
	struct drbg_aes_ctx *ctx;
	const uint8_t *dt;
	unsigned counter;
};

static int get_dt(void *_priv, uint8_t dt[AES_BLOCK_SIZE])
{
	struct priv_st *priv = _priv;

	memcpy(dt, priv->dt, AES_BLOCK_SIZE);

	dt[12] = priv->counter >> 24;
	dt[13] = priv->counter >> 16;
	dt[14] = priv->counter >> 8;
	dt[15] = priv->counter;

	priv->counter++;

	return 1;
}

/* Run a Know-Answer-Test using a dedicated test context.  Note that
   we can't use the samples from the NISR RNGVS document because they
   don't take the requirement to throw away the first block and use
   that for duplicate check in account.  Thus we made up our own test
   vectors. */
int drbg_aes_self_test(void)
{
	static const struct self_test_st tv[] = {
		{
		 {0xb9, 0xca, 0x7f, 0xd6, 0xa0, 0xf5, 0xd3, 0x42,
		  0x19, 0x6d, 0x84, 0x91, 0x76, 0x1c, 0x3b, 0xbe},
		 {0x48, 0xb2, 0x82, 0x98, 0x68, 0xc2, 0x80, 0x00,
		  0x00, 0x00, 0x28, 0x18, 0x00, 0x00, 0x25, 0x00},
		 {0x52, 0x17, 0x8d, 0x29, 0xa2, 0xd5, 0x84, 0x12,
		  0x9d, 0x89, 0x9a, 0x45, 0x82, 0x02, 0xf7, 0x77},
		 {
		  {0x42, 0x9c, 0x08, 0x3d, 0x82, 0xf4, 0x8a, 0x40,
		   0x66, 0xb5, 0x49, 0x27, 0xab, 0x42, 0xc7, 0xc3},
		  {0x0e, 0xb7, 0x61, 0x3c, 0xfe, 0xb0, 0xbe, 0x73,
		   0xf7, 0x6e, 0x6d, 0x6f, 0x1d, 0xa3, 0x14, 0xfa},
		  {0xbb, 0x4b, 0xc1, 0x0e, 0xc5, 0xfb, 0xcd, 0x46,
		   0xbe, 0x28, 0x61, 0xe7, 0x03, 0x2b, 0x37, 0x7d}
		  }
		 },
		{
		 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		 {
		  {0xc8, 0xd1, 0xe5, 0x11, 0x59, 0x52, 0xf7, 0xfa,
		   0x37, 0x38, 0xb4, 0xc5, 0xce, 0xb2, 0xb0, 0x9a},
		  {0x0d, 0x9c, 0xc5, 0x0d, 0x16, 0xe1, 0xbc, 0xed,
		   0xcf, 0x60, 0x62, 0x09, 0x9d, 0x20, 0x83, 0x7e},
		  {0x6f, 0x39, 0xe0, 0xcb, 0x76, 0x7c, 0x0d, 0xeb,
		   0xff, 0xa0, 0x0e, 0x54, 0xe8, 0x9b, 0xa6, 0x79}
		  }
		 },
		{
		 {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
		  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f},
		 {0x80, 0x00, 0x81, 0x01, 0x82, 0x02, 0x83, 0x03,
		  0xa0, 0x20, 0xa1, 0x21, 0xa2, 0x22, 0xa3, 0x23},
		 {0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
		  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
		 {
		  {0x7a, 0x14, 0x76, 0x77, 0x95, 0x17, 0x7e, 0xc8,
		   0x92, 0xe8, 0xdd, 0x15, 0xcb, 0x1f, 0xbc, 0xb1},
		  {0x25, 0x3e, 0x2e, 0xa2, 0x41, 0x1b, 0xdd, 0xf5,
		   0x21, 0x48, 0x41, 0x71, 0xb3, 0x8d, 0x2f, 0x4c},
		  {0xc3, 0xa0, 0x56, 0xc4, 0x98, 0x56, 0xe7, 0xa5,
		   0x19, 0x42, 0x73, 0x43, 0xdc, 0x07, 0xe0, 0x7f}
		  }
		 }
	};
	unsigned i, j;
	struct drbg_aes_ctx test_ctx;
	struct priv_st priv;
	int ret;
	unsigned char result[16];

	memset(&priv, 0, sizeof(priv));
	priv.ctx = &test_ctx;

	for (i = 0; i < sizeof(tv) / sizeof(tv[0]); i++) {
		/* Setup the key.  */
		ret = drbg_aes_set_key(&test_ctx, 16, tv[i].key);
		if (ret == 0)
			return 0;

		priv.dt = tv[i].dt;
		priv.counter =
		    ((tv[i].dt[12] << 24) | (tv[i].dt[13] << 16) | (tv[i].
								    dt[14]
								    << 8) |
		     (tv[i].dt[15]));

		/* Setup the seed.  */
		drbg_aes_seed(&test_ctx, tv[i].v, &priv, get_dt);

		if (drbg_aes_is_seeded(&test_ctx) == 0)
			return 0;

		/* Get and compare the first three results.  */
		for (j = 0; j < 3; j++) {
			/* Compute the next value.  */
			if (drbg_aes_random
			    (&test_ctx, 16, result) == 0)
				return 0;

			/* Compare it to the known value.  */
			if (memcmp(result, tv[i].r[j], 16) != 0)
				return 0;
		}
	}

	return 1;
}
