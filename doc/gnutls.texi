\input texinfo   @c -*-texinfo-*-
@comment $Id$
@comment %**start of header
@setfilename gnutls.info
@include version.texi
@settitle GNU TLS @value{VERSION}
@syncodeindex pg cp
@comment %**end of header
@copying
This manual is for GNU TLS
(version @value{VERSION}, @value{UPDATED}),
a Transport Layer Security Library.

Copyright @copyright{} 2001,2002,2003,2004 Nikos Mavroyanopoulos
Copyright @copyright{} 2004 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the section entitled "GNU
Free Documentation License".
@end quotation
@end copying

@dircategory GNU Libraries
@direntry
* libgnutls: (gnutls).		A Transport Layer Security Library.
@end direntry

@titlepage
@title GNU TLS
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Nikos Mavroyanopoulos (@email{bug-gnutls@@gnu.org})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top GNU TLS

@insertcopying
@end ifnottex

@menu
* Preface::
* The Library::
* Copying This Manual::
* Index::
@end menu


@node Preface
@chapter Preface

@section Introduction

This document tries to demonstrate and explain the @acronym{GnuTLS}
library API.  A brief introduction to the protocols and the technology
involved, is also included so that an application programmer can
better understand the @acronym{GnuTLS} purpose and actual offerings.
Even if @acronym{GnuTLS} is a typical library software, it operates
over several security and cryptographic protocols, which require the
programmer to make careful and correct usage of them, otherwise he
risks to offer just a false sense of security. Security and the
network security terms are very general terms even for computer
software thus cannot be easily restricted to a single cryptographic
library.  For that reason, do not consider a program secure just
because it uses @acronym{GnuTLS}; there are several ways to compromise
a program or a communication line and @acronym{GnuTLS} only helps with
some of them.

This document tries to be self contained, although basic network
programming and PKI knowlegde is assumed in most of it.  \cite{GUTPKI}
is a good introduction to Public Key Infrastructure.

@section Availability

Updated versions of the @acronym{GnuTLS} software and this document
will be available from @url{http://www.gnutls.org/} and
@url{http://www.gnu.org/software/gnutls/}.

@node The Library
@chapter The Library

In brief @acronym{GnuTLS} can be described as a library which offers an API
to access secure communication protocols. These protocols provide
privacy over insecure lines, and were designed to prevent
eavesdropping, tampering, or message forgery.

Technically @acronym{GnuTLS} is a portable ANSI C based library which
implements the TLS 1.0@footnote{See section \ref{sec:tlsintro} on page
\pageref{sec:tlsintro} for a more detailed description of the
protocols.} and SSL 3.0 protocols, accompanied with the required
framework for authentication and public key infrastructure.  The
library is available under the GNU Lesser GPL license@footnote{A copy
of the license is included in the distribution}.  Important features
of the @acronym{GnuTLS} library include:

@itemize

@item Support for TLS 1.0, TLS 1.1, and SSL 3.0 protocols.

@item Support for both @acronym{X.509} and @acronym{OpenPGP} certificates.

@item Support for handling and verification of certificates.

@item Support for SRP for TLS authentication.

@item Support for TLS Extension mechanism.

@item Support for TLS Compression Methods.

@end itemize

Additionally @acronym{GnuTLS} provides a limited emulation API for the
widely used OpenSSL@footnote{@url{http://www.openssl.org/}} library,
to ease integration with existing applications.

@acronym{GnuTLS} consists of three independent parts, namely the ``TLS
protocol part'', the ``Certificate part'', and the ``Crypto backend''
part.  The `TLS protocol part' is the actual protocol implementation,
and is entirely implemented within the @acronym{GnuTLS} library.  The
`Certificate part' consists of the certificate parsing, and
verification functions which is partially implemented in the
@acronym{GnuTLS} library.  The
@acronym{Libtasn1}@footnote{@url{ftp://ftp.gnupg.org/gcrypt/alpha/gnutls/libtasn1/}},
a library which offers ASN.1 parsing capabilities, is used for the
X.509 certificate parsing functions, and
@acronym{Opencdk}@footnote{@url{ftp://ftp.gnupg.org/gcrypt/alpha/gnutls/opencdk/}}
is used for the OpenPGP key support in @acronym{GnuTLS}.  The ``Crypto
backend'' is provided by the
@acronym{Libgcrypt}@footnote{@url{ftp://ftp.gnupg.org/gcrypt/alpha/libgcrypt/}}
library.

In order to ease integration in embedded systems, parts of the
@acronym{GnuTLS} library can be disabled at compile time. That way a
small library, with the required features, can be generated.

@section General Idea

@c explain how it works

A brief description of how @acronym{GnuTLS} works internally is shown at the
figure \ref{fig:internals}. This section may be easier to understand
after having seen the examples on page \pageref{examples}.

\begin{figure}[htp]
\includegraphics[height=8cm,width=12cm]{internals}
\label{fig:internals}
\end{figure}

As shown in the figure, there is a read-only global state that is
initialized once by the global initialization function.  This global
structure, among others, contains the memory allocation functions
used, and some structures needed for the ASN.1 parser.  This structure
is never modified by any @acronym{GnuTLS} function, except for the
deinitialization function which frees all memory allocated in the
global structure and is called after the program has permanently
finished using @acronym{GnuTLS}.

The credentials structure is used by some authentication methods, such
as certificate authentication\footnote{see section \ref{certificate}
on page \pageref{certificate}}.  A credentials structure may contain
certificates, private keys, temporary parameters for diffie hellman or
RSA key exchange, and other stuff that may be shared between several
TLS sessions.

This structure should be initialized using the appropriate initialization
functions. For example an application which uses certificate authentication
would probably initialize the credentials, using the appropriate functions,
and put its trusted certificates in this structure. The next step is to
associate the credentials structure with each @acronym{TLS} session.

A @acronym{GnuTLS} session contains all the required stuff for a
session to handle one secure connection. This session calls directly
to the transport layer functions, in order to communicate with the
peer.  Every session has a unique session ID shared with the peer.

Since TLS sessions can be resumed, servers would probably need a
database backend to hold the session's parameters. Every
@acronym{GnuTLS} session after a successful handshake calls the
appropriate backend function\footnote{see section \ref{resume} on
\pageref{resume} for information on initialization} to store the newly
negotiated session. The session database is examined by the server
just after having received the client hello\footnote{The first message
in a @acronym{TLS} handshake}, and if the session ID sent by the
client, matches a stored session, the stored session will be
retrieved, and the new session will be a resumed one, and will share
the same session ID with the previous one.

@section Error handling

In @acronym{GnuTLS} most functions return an integer type as a result.  In
almost all cases a zero or a positive number means success, and a
negative number indicates failure, or a situation that some action has
to be taken. Thus negative error codes may be fatal or not.

Fatal errors terminate the connection immediately and further sends
and receives will be disallowed. An example of a fatal error code is
GNUTLS\_E\_DECRYPTION\_FAILED. Non-fatal errors may warn about
something, ie a warning alert was received, or indicate the some
action has to be taken. This is the case with the error code
GNUTLS\_E\_REHANDSHAKE returned by
\printfunc{gnutls_record_recv}{gnutls\_record\_recv}.  This error code
indicates that the server requests a re-handshake. The client may
ignore this request, or may reply with an alert.  You can test if an
error code is a fatal one by using the
\printfunc{gnutls_error_is_fatal}{gnutls\_error\_is\_fatal}.

If any non fatal errors, that require an action, are to be returned by
a function, these error codes will be documented in the function's
reference. All the error codes are documented in appendix
\ref{ap:error_codes} on page \pageref{ap:error_codes}.

@section Memory handling

@acronym{GnuTLS} internally handles heap allocated objects differently,
depending on the sensitivity of the data they contain. However for
performance reasons, the default memory functions do not overwrite
sensitive data from memory, nor protect such objects from being
written to the swap.  In order to change the default behavior the
\printfunc{gnutls_global_set_mem_functions}{gnutls\_global\_set\_mem\_functions}
function is available which can be used to set other memory handlers
than the defaults.

The @acronym{Libgcrypt} library on which @acronym{GnuTLS} depends, has such
secure memory allocation functions available. These should be used in
cases where even the system's swap memory is not considered
secure. See the documentation of @acronym{Libgcrypt} for more
information.

@section Callback functions
@cindex Callback functions

There are several cases where @acronym{GnuTLS} may need some out of
band input from your program. This is now implemented using some
callback functions, which your program is expected to register.

An example of this type of functions are the push and pull callbacks
which are used to specify the functions that will retrieve and send
data to the transport layer.

@itemize

@item \printfunc{gnutls_transport_set_push_function}{gnutls\_transport\_set\_push\_function}
@item \printfunc{gnutls_transport_set_pull_function}{gnutls\_transport\_set\_pull\_function}

@end itemize

Other callback functions such as the one set by
\printfunc{gnutls_srp_set_server_credentials_function}{gnutls\_srp\_set\_server\_credentials\_function},
may require more complicated input, including data to be allocated.
These callbacks should allocate and free memory using the functions
shown below.

@itemize

@item \printfunc{gnutls_malloc}{gnutls\_malloc}

@item \printfunc{gnutls_free}{gnutls\_free}

@end itemize

@node Copying This Manual
@appendix Copying This Manual

@menu
* GNU Free Documentation License::  License for copying this manual.
@end menu

@include fdl.texi


@node Index
@unnumbered Index

@printindex cp

@bye
