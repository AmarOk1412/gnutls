\begin{verbatim}

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>
#include <gnutls.h>

#define KEYFILE "key.pem"
#define CERTFILE "cert.pem"
#define CAFILE "ca.pem"
#define CRLFILE NULL

#define SRP_PASSWD "tpasswd"
#define SRP_PASSWD_CONF "tpasswd.conf"


/* This is a sample TCP echo server.
 */


#define SA struct sockaddr
#define ERR(err,s) if(err==-1) {perror(s);return(1);}
#define MAX_BUF 1024
#define PORT 5556 /* listen to 5556 port */

/* These are global */
SRP_SERVER_CREDENTIALS srp_cred;
X509PKI_SERVER_CREDENTIALS x509_cred;

GNUTLS_STATE initialize_state()
{
       GNUTLS_STATE state;
       int ret;

       gnutls_init(&state, GNUTLS_SERVER);
	
       /* in order to support session resuming:
        */
       if ((ret = gnutls_set_db_name(state, "gnutls-rsm.db")) < 0)
	      fprintf(stderr, "*** DB error (%d)\n\n", ret);

       gnutls_set_cipher_priority(state, GNUTLS_RIJNDAEL_CBC, GNUTLS_3DES_CBC, 0);
       gnutls_set_compression_priority(state, GNUTLS_ZLIB, GNUTLS_NULL_COMPRESSION, 0);
       gnutls_set_kx_priority(state, GNUTLS_KX_RSA, GNUTLS_KX_SRP, 0);
       gnutls_set_protocol_priority(state, GNUTLS_TLS1, GNUTLS_SSL3, 0);
       gnutls_set_mac_priority(state, GNUTLS_MAC_SHA, GNUTLS_MAC_MD5, 0);

       gnutls_set_cred(state, GNUTLS_SRP, srp_cred);
       gnutls_set_cred(state, GNUTLS_X509PKI, x509_cred);


       return state;
}

void print_info(GNUTLS_STATE state)
{
       const SRP_SERVER_AUTH_INFO *srp_info;
       const char *tmp;
       unsigned char sesid[32];
       int sesid_size, i;

       /* print session_id specific data */
       gnutls_get_current_session_id(state, sesid, &sesid_size);
       printf("\n- Session ID: ");
       for (i = 0; i < sesid_size; i++)
	      printf("%.2X", sesid[i]);
       printf("\n");

       /* print srp specific data */
       if (gnutls_get_auth_info_type(state) == GNUTLS_SRP) {
	      srp_info = gnutls_get_auth_info(state);
	      if (srp_info != NULL)
		     printf("\n- User '%s' connected\n",
			    srp_info->username);
       }
       /* print state information */
       tmp = gnutls_version_get_name(gnutls_get_current_version(state));
       printf("- Version: %s\n", tmp);

       tmp = gnutls_kx_get_name(gnutls_get_current_kx(state));
       printf("- Key Exchange: %s\n", tmp);

       tmp =
	   gnutls_compression_get_name
	   (gnutls_get_current_compression_method(state));
       printf("- Compression: %s\n", tmp);

       tmp = gnutls_cipher_get_name(gnutls_get_current_cipher(state));
       printf("- Cipher: %s\n", tmp);

       tmp = gnutls_mac_get_name(gnutls_get_current_mac_algorithm(state));
       printf("- MAC: %s\n", tmp);

}



int main()
{
       int err, listen_sd, i;
       int sd, ret;
       struct sockaddr_in sa_serv;
       struct sockaddr_in sa_cli;
       int client_len;
       char topbuf[512];
       GNUTLS_STATE state;
       char buffer[MAX_BUF + 1];
       int optval = 1;
       int http = 0;
       char name[256];

       strcpy(name, "Echo Server");

       /* this must be called once in the program
        */
       if (gnutls_global_init() < 0) {
	      fprintf(stderr, "global state initialization error\n");
	      exit(1);
       }
       if (gnutls_allocate_x509_server_sc(&x509_cred, 1) < 0) {
	      fprintf(stderr, "memory error\n");
	      exit(1);
       }
       if (gnutls_set_x509_server_trust(x509_cred, CAFILE, CRLFILE) < 0) {
	      fprintf(stderr, "X509 PARSE ERROR\nDid you have ca.pem?\n");
	      exit(1);
       }
       if (gnutls_set_x509_server_key(x509_cred, CERTFILE, KEYFILE) < 0) {
	      fprintf(stderr, "X509 PARSE ERROR\nDid you have key.pem and cert.pem?\n");
	      exit(1);
       }
       /* SRP_PASSWD a password file (created with the included crypt utility) 
        * Read README.crypt prior to using SRP.
        */
       gnutls_allocate_srp_server_sc(&srp_cred);
       gnutls_set_srp_server_cred(srp_cred, SRP_PASSWD, SRP_PASSWD_CONF);


       /* Socket operations
        */
       listen_sd = socket(AF_INET, SOCK_STREAM, 0);
       ERR(listen_sd, "socket");

       memset(&sa_serv, '\0', sizeof(sa_serv));
       sa_serv.sin_family = AF_INET;
       sa_serv.sin_addr.s_addr = INADDR_ANY;
       sa_serv.sin_port = htons(PORT);	/* Server Port number */

       setsockopt(listen_sd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(int));
       
       err = bind(listen_sd, (SA *) & sa_serv, sizeof(sa_serv));
       ERR(err, "bind");
       err = listen(listen_sd, 1024);
       ERR(err, "listen");

       printf("%s ready. Listening to port '%d'.\n\n", name, PORT);

       client_len = sizeof(sa_cli);
       for (;;) {
	      state = initialize_state();

	      sd = accept(listen_sd, (SA *) & sa_cli, &client_len);

	      printf("- connection from %s, port %d\n",
		     inet_ntop(AF_INET, &sa_cli.sin_addr, topbuf,
			       sizeof(topbuf)), ntohs(sa_cli.sin_port));


	      ret = gnutls_handshake(sd, state);
	      if (ret < 0) {
		     close(sd);
		     gnutls_deinit(state);
		     fprintf(stderr, "*** Handshake has failed (%s)\n\n",
			     gnutls_strerror(ret));
		     continue;
	      }
	      printf("- Handshake was completed\n");

	      print_info(state);

	      i = 0;
	      for (;;) {
		     bzero(buffer, MAX_BUF + 1);
		     ret = gnutls_read(sd, state, buffer, MAX_BUF);

		     if (gnutls_is_fatal_error(ret) == 1 || ret == 0) {
			    if (ret == 0) {
				   printf
				       ("\n- Peer has closed the GNUTLS connection\n");
				   break;
			    } else {
				   fprintf(stderr,
					   "\n*** Received corrupted data(%d). Closing the connection.\n\n",
					   ret);
				   break;
			    }

		     }
		     if (ret > 0) {
			    /* echo data back to the client
			     */
			    gnutls_write(sd, state, buffer,
					 strlen(buffer));
		     }
		     if (ret == GNUTLS_E_WARNING_ALERT_RECEIVED || ret == GNUTLS_E_FATAL_ALERT_RECEIVED) {
			    ret = gnutls_get_last_alert(state);
			    printf("* Received alert '%d'.\n", ret);
		     }
	      }
	      printf("\n");
	      gnutls_bye(sd, state, 1); /* do not wait for
	                                 * the peer to close the connection.
                                         */
                                         
	      close(sd);
	      gnutls_deinit(state);

       }
       close(listen_sd);

       gnutls_free_x509_server_sc(x509_cred);
       gnutls_free_srp_server_sc(srp_cred);

       gnutls_global_deinit();

       return 0;

}

\end{verbatim}
