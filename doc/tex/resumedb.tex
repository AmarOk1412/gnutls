\section{Resuming Sessions}
\par
The 
\hyperref{gnutls\_handshake()}{gnutls\_handshake() (see Section }{ for more information)}{gnutls_handshake}
 function, is expensive since a lot of calculations are performed. In order to support many fast connections to
the same server a client may use session resuming. {\bf Session resuming} is a
feature of the {\bf TLS} protocol which allows a client to connect to a server,
after a successful handshake, without the expensive calculations (by using the previously
established keys). \gnutls supports this feature, and the
example \hyperref{resume client}{resume client (see Section }{ for more
information)}{resume-example} illustrates a typical use of it (This is a modification of the simple client example).
Servers only need to use the
\hyperref{gnutls\_db\_set\_name()}{gnutls\_db\_set\_name() (see Section }{ for more
information)}{gnutls_db_set_name} function if they want to use the gdbm
backend to store sessions. 
\par
Keep in mind that sessions are expired after some time (for security reasons), thus
it may be normal for a server not to resume a session even if you requested that.
Also note that you must enable (using the priority functions), at least the
algorithms used in the last session.

\subsection{Resuming internals}
The resuming capability (mostly in the server side) is one of the problems of a thread-safe TLS
implementations. The problem is that all threads must share information in
order to be able to resume sessions. The gnutls approach is, in case of a
client, to leave all the burden of resuming to the client (ie. copy and keep the
nesessary parameters etc.).
\par
The server side is different\footnote{Future versions of gnutls may be
different}. 
Here the server only specifies a DB file (using 
\hyperref{gnutls\_db\_set\_name()}{gnutls\_db\_set\_name() (see Section }{ for more
information)}{gnutls_db_set_name}
) to be used. This DB file is used to store the sessions' required parameters for
resuming (and this means that this file contains very sensitive information,
such as encryption keys). In a multi-threaded application every thread can
read from the DB file and access all previously established sessions, but
only one thread can write at a time. The current behaviour of gnutls is
not to block and wait for the DB to be ready for writing, but continue the
process normally (and do not save the parameters).  
\par
 After version {\emph 0.2.10} \gnutls provides callback functions such as:
\hyperref{gnutls\_db\_set\_remove\_function()}{gnutls\_db\_set\_remove\_function() (see Section }{ for more
information)}{gnutls_db_set_remove_function},
\hyperref{gnutls\_db\_set\_store\_function()}{gnutls\_db\_set\_store\_function() (see Section }{ for more
information)}{gnutls_db_set_store_function},
\hyperref{gnutls\_db\_set\_retrieve\_function()}{gnutls\_db\_set\_retrieve\_function() (see Section }{ for more
information)}{gnutls_db_set_retrieve_function} and
\hyperref{gnutls\_db\_set\_ptr()}{gnutls\_db\_set\_ptr() (see Section }{ for more
information)}{gnutls_db_set_ptr}.
These callback functions are required in order to use a session
storage method, other than the default gdbm backend. 
\par
If an alternative backend is in use, it might be usefull to be able to check
for expired sessions in order to remove them, and save space (in the way 
\hyperref{gnutls\_db\_clean()}{gnutls\_db\_clean() (see Section }{ for more
information)}{gnutls_db_clean}.
) does for the gdbm backend. \gnutls provides the function
\hyperref{gnutls\_db\_check\_entry()}{gnutls\_db\_check\_entry() (see Section }{ for more
information)}{gnutls_db_check_entry}, which takes as input session data, and
returns a negative value if the data are to be removed.

