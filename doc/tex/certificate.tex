\chapter{More on certificate authentication}
\index{Certificate authentication}
\label{certificate}

\section{The X.509\index{X.509 certificates} trust model}
\label{x509:trust}

The X.509 protocols rely on a hierarchical trust model. In this trust model
Certification Authorities (CAs) are used to certify entities.
Usually more than one certification authorities exist, and certification
authorities may certify other authorities to issue certificates as well,
following a hierarchical model. 
One needs to trust one or more CAs for his secure
communications. In that case only the certificates issued by the trusted
authorities are acceptable. See figure \ref{fig:x509-1} for a typical example.

\begin{figure}[hbtp]
\includegraphics[height=9.5cm,width=9cm]{x509-1}
\label{fig:x509-1}
\end{figure}


The API for handling X.509 certificates is described at section \ref{sec:x509api}
on page \pageref{sec:x509api}. Some examples are listed below.


\subsection{Verifying an X.509 certificate}
Verifying certificate\index{Verifying certificate paths} paths is important 
in X.509 authentication. For this purpose the function
\printfunc{gnutls_x509_crt_verify}{gnutls\_x509\_crt\_verify} is provided. The
output of this function is the bitwise OR of the elements of the
``gnutls\_certificate\_status'' enumeration. A detailed description of
these elements can be found in figure \ref{fig:verify}.
The function \printfunc{gnutls_certificate_verify_peers}{gnutls\_certificate\_verify\_peers}
is equivalent to the previous one, and will verify the peer's certificate in a TLS session.

\begin{figure}[hbtp]
\begin{tabular}{|l|p{9cm}|}

\hline
CERT\_INVALID & The certificate chain is broken. 
\\
\hline
CERT\_NOT\_TRUSTED & The certificate is not signed by one of the authorities marked as trusted.
\\
\hline
CERT\_REVOKED & The certificate has been revoked.
\\
\hline
CERT\_CORRUPTED & The certificate is corrupted.
\\
\hline
\end{tabular}
\caption{Certificate verification}
\label{fig:verify}
\end{figure}

\par
Although the verification of a certificate path indicates that the
certificate is signed by trusted authority, does not reveal anything
about the peer's identity. It is required to verify if the certificate's
owner is the one you expect. See section \ref{ex:rfc2818} on page \pageref{ex:rfc2818},
for an example.

\par
Client certificate authentication\index{Certificate authentication!Client} is 
optional in \tls{}. A server may request a certificate from the client -- using the
\printfunc{gnutls_certificate_server_set_request}{gnutls\_certificate\_server\_set\_request}
function. If a certificate is to be requested by the client, at the handshake 
procedure, the server will send an extra packet,
than contains a list of acceptable certificate signers, and indicates the
request of a certificate. The client may then send a certificate, signed
by one of the server's acceptable signers. In \gnutls{} the server's acceptable
signers list is constructed using the trusted CA certificates in the
credentials structure.

\section{Using X.509\index{X.509 certificates} certificates and other structures}

\subsection{Parsing an X.509 certificate}
An X.509 certificate usually contains information about the certificate
holder, the signer, a unique serial number, expiration dates etc. Some
function of the \gnutls{} API for certificate parsing are:
\begin{itemize}
\item \printfunc{gnutls_x509_crt_init}{gnutls\_x509\_crt\_init}
\item \printfunc{gnutls_x509_crt_import}{gnutls\_x509\_crt\_import}
\item \printfunc{gnutls_x509_crt_get_dn}{gnutls\_x509\_crt\_get\_dn}
\item \printfunc{gnutls_x509_crt_get_serial}{gnutls\_x509\_crt\_get\_serial}
\item \printfunc{gnutls_x509_crt_get_subject_alt_name}{gnutls\_x509\_crt\_get\_subject\_alt\_name}
\end{itemize}

\par
An example is shown below, that reads the peer's certificate,
and prints some information about the peer's certificate in a TLS session.

\input{ex-x509-info}

\subsection{Using certificate requests}
A certificate request is a structure, defined in PKCS \#10, which
is contains information about an applicant of a certificate service.
It usually contains a private key, a distinguished name and secondary
data such as a challenge password.
\par
The following example is about generating a certificate request, and
a private key. A certificate request can be later be processed by a CA,
which should return a signed certificate.

\input{ex-crq}

\subsection{Using PKCS \#12 structures}
A PKCS \#12 structure usually contains a user's private keys and
certificates. It is commonly used in browsers to export and import
the user's identities.

\par
The following example is about generating a PKCS \#12 structure.

\input{ex-pkcs12}


\section{The OpenPGP\index{OpenPGP!Keys} trust model}
\label{pgp:trust}

The OpenPGP key authentication relies on a distributed trust model, called
the "web of trust". The "web of trust" uses a decentralized system of 
trusted introducers, which are the same as a CA. OpenPGP allows anyone to 
sign anyone's else public key. When Alice signs Bob's key, she is introducing 
Bob's key to anyone who trusts Alice. If someone trusts Alice to introduce
keys, then Alice is a trusted introducer in the mind of that observer.

\begin{figure}[hbtp]
\includegraphics[height=9cm,width=11cm]{pgp-fig1}
\label{fig:pgp1}
\end{figure}

For example: If David trusts Alice to be an introducer, and Alice signed
Bob's key, Dave also trusts Bob's key to be the real one.

There are some key points that are important in that model. In the example
Alice has to sign Bob's key, only if she is sure that the key belongs
to Bob. Otherwise she may also make Dave falsely believe that this
is Bob's key. Dave has also the responsibility to know who to trust.
This model is similar to real life relations.

Just see how Charlie behaves in the previous example. Although he has 
signed Bob's key - because he knows, somehow, that it belongs to Bob - 
he does not trust Bob to be an introducer. Charlie decided to trust only 
Kevin, for some reason. A reason could be that Bob is lazy enough, and 
signs other people's keys without being sure that they belong to the 
actual owner.

\subsection{Verifying an OpenPGP key}
First we've to differentiate between ownertrust and validity. Sometimes trust
and validity is used as a synonym but this is not correct.
\par
The ownertrust describes how trustworthy the signature of a special
key owner is. Even if we've three or more signatures to make a key valid,
it's possible that we don't trust the owner at all and thus we don't trust 
the signature he made. There are different ownertrust levels:
\begin{enumerate}
\item Don't know
\item I do NOT trust
\item I trust marginally
\item I trust fully
\item I trust ultimately.
\end{enumerate}

For example we need three marginally trusted signature to make a key
valid or one full trusted signature. The ultimate trust is only used
when we are the owner of a key and we also have the secret key.
In the case we don't trust the owner, those signatures are skipped
for the web of trust calculation.
\par
All checks in GnuTLS are done in \printfunc{gnutls_openpgp_verify_key}{gnutls\_openpgp\_verify\_key}. 
If a trust database is available, this is the file which contains all information about the
key owner (ownertrust), additional checks are performed.
\\
First we get the trustdb entry to see if the key is not disabled because
those keys shouldn't be used at all. Another possible case is that we
don't trust the key, which means we don't need to perform further checks.
\par
If the ownertrust is at least marginal we continue to check all signatures
the key contains to get the validity of the key. It is likely that the
public keyring does not contain all needed keys to check all signatures.
When a signature could not be checked due to a missing key, the function 
tries the next signature. When NO public key is available, the function
checks at least the self signature which must be valid in any case because
it was created by the key itself.
\\
Validity means if the signatures on the key are valid and the key was not 
changed by somebody or corrupted during transport.

