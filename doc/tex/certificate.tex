\chapter{More on certificate authentication}
\index{Certificate authentication}
\label{certificate}

\section{The X.509\index{X.509 certificates} trust model}
\label{x509:trust}

The X.509 protocols rely on a hierarchical trust model. In this trust model
Certification Authorities (CAs) are used to certify entities.
Usually more than one certification authorities exist, and certification
authorities may certify other authorities to issue certificates as well,
following a hierarchical model. 
One needs to trust one or more CAs for his secure
communications. In that case only the certificates issued by the trusted
authorities are acceptable. See figure \ref{fig:x509-1} for a typical example.

\begin{figure}[hbtp]
\includegraphics[height=9.5cm,width=9cm]{x509-1}
\label{fig:x509-1}
\end{figure}


The API for handling X.509 certificates is described at section \ref{sec:x509api}
on page \pageref{sec:x509api}. Some examples are listed below.



\subsection*{X.509 certificates}
An X.509 certificate usually contains information about the certificate
holder, the signer, a unique serial number, expiration dates etc. Some
functions of \gnutls{}' API for certificate parsing are:
\begin{itemize}
\item \printfunc{gnutls_x509_crt_init}{gnutls\_x509\_crt\_init}
\item \printfunc{gnutls_x509_crt_import}{gnutls\_x509\_crt\_import}
\item \printfunc{gnutls_x509_crt_get_dn}{gnutls\_x509\_crt\_get\_dn}
\item \printfunc{gnutls_x509_crt_get_serial}{gnutls\_x509\_crt\_get\_serial}
\item \printfunc{gnutls_x509_crt_get_subject_alt_name}{gnutls\_x509\_crt\_get\_subject\_alt\_name}
\end{itemize}

\par
An example program that reads the peer's certificate,
and prints some information about the peer's certificate in a TLS session,
is listed below.

\input{ex-x509-info}


\subsection*{Verifying X.509 certificate paths}
Verifying certificate\index{Verifying certificate paths} paths is important 
in X.509 authentication. For this purpose the function
\printfunc{gnutls_x509_crt_verify}{gnutls\_x509\_crt\_verify} is provided. The
output of this function is the bitwise OR of the elements of the
``gnutls\_certificate\_status'' enumeration. A detailed description of
these elements can be found in figure \ref{fig:verify}.
The function \printfunc{gnutls_certificate_verify_peers}{gnutls\_certificate\_verify\_peers}
is equivalent to the previous one, and will verify the peer's certificate in a TLS session.

\begin{figure}[hbtp]
\begin{tabular}{|l|p{9cm}|}

\hline
CERT\_INVALID & The certificate is not signed by one of the known authorities, or
the signature is invalid.
\\
\hline
CERT\_REVOKED & The certificate has been revoked.
\\
\hline
CERT\_SIGNER\_NOT\_FOUND & The certificate's issuer is not known.
\\
\hline
\end{tabular}
\caption{X.509 certificate verification}
\label{fig:verify}
\end{figure}

\par
Although the verification of a certificate path indicates that the
certificate is signed by trusted authority, does not reveal anything
about the peer's identity. It is required to verify if the certificate's
owner is the one you expect. See section \ref{ex:rfc2818} on page \pageref{ex:rfc2818},
for an example.


\subsection*{PKCS \#10 certificate requests\index{Certificate requests}\index
{PKCS \#10}}
A certificate request is a structure, which
is contains information about an applicant of a certificate service.
It usually contains a private key, a distinguished name and secondary
data such as a challenge password. \gnutls{} supports the requests
defined in PKCS \#10. Other certificate request's format such as
PKIX's RFC2511 are not currently supported.
\par
The following example is about generating a certificate request, and
a private key. A certificate request can be later be processed by a CA,
which should return a signed certificate.

\input{ex-crq}

\subsection*{PKCS \#12 structures\index{PKCS \#12}}
A PKCS \#12 structure usually contains a user's private keys and
certificates. It is commonly used in browsers to export and import
the user's identities.
\par
In \gnutls{} the PKCS \#12 structures are handled using the
\emph{gnutls\_pkcs12} type. This is an abstract type that
may hold several \emph{gnutls\_pkcs12\_bag} types. The Bag types are the
holders of the actual data, which may be certificates, private
keys or encrypted data. An Bag of type encrypted should be decrypted
in order for its data to be accessed. 
\par
The following example is about generating a PKCS \#12 structure.

\input{ex-pkcs12}


\section{The OpenPGP\index{OpenPGP!Keys} trust model}
\label{pgp:trust}

The OpenPGP key authentication relies on a distributed trust model, called
the "web of trust". The "web of trust" uses a decentralized system of 
trusted introducers, which are the same as a CA. OpenPGP allows anyone to 
sign anyone's else public key. When Alice signs Bob's key, she is introducing 
Bob's key to anyone who trusts Alice. If someone trusts Alice to introduce
keys, then Alice is a trusted introducer in the mind of that observer.

\begin{figure}[hbtp]
\includegraphics[height=9cm,width=11cm]{pgp-fig1}
\label{fig:pgp1}
\end{figure}

For example: If David trusts Alice to be an introducer, and Alice signed
Bob's key, Dave also trusts Bob's key to be the real one.

There are some key points that are important in that model. In the example
Alice has to sign Bob's key, only if she is sure that the key belongs
to Bob. Otherwise she may also make Dave falsely believe that this
is Bob's key. Dave has also the responsibility to know who to trust.
This model is similar to real life relations.

Just see how Charlie behaves in the previous example. Although he has 
signed Bob's key - because he knows, somehow, that it belongs to Bob - 
he does not trust Bob to be an introducer. Charlie decided to trust only 
Kevin, for some reason. A reason could be that Bob is lazy enough, and 
signs other people's keys without being sure that they belong to the 
actual owner.

\subsection*{Verifying an OpenPGP key}
The verification functions of OpenPGP keys, included in \gnutls{}, 
are simple ones, and do not use the features of the ``web of trust''.
For that reason, if the verification needs are complex, 
the assistance of external tools like GnuPG is recommended.
\par
There are two verification functions in \gnutls{},
The \printfunc{gnutls_openpgp_key_verify_ring}{gnutls\_openpgp\_key\_verify\_ring}
and the \printfunc{gnutls_openpgp_key_verify_trustdb}{gnutls\_openpgp\_key\_verify\_trustdb}. 
\\
The first one checks an OpenPGP key against a given set of public keys (keyring) and
returns the key status. The key verification status is the same as in X.509 certificates,
although the meaning and interpretation are different. For example an OpenPGP key may
be valid, if the self signature is ok, even if no signers were found.
The meaning of verification status is shown in figure \ref{fig:pgp_verify}.
\\
The latter function checks a GnuPG trust database for the given key. This function does not
check the key signatures, only checks for disabled and revoked keys.

\begin{figure}[hbtp]
\begin{tabular}{|l|p{9cm}|}

\hline
CERT\_INVALID & A signature on the key is invalid. That means that the key was modified
by somebody, or corrupted during transport.
\\
\hline
CERT\_REVOKED & The key has been revoked by its owner.
\\
\hline
CERT\_SIGNER\_NOT\_FOUND & The key was not signed by a known signer.
\\
\hline
\end{tabular}
\caption{OpenPGP key verification}
\label{fig:pgp_verify}
\end{figure}

