@node More on certificate authentication
@chapter More on certificate authentication
@cindex certificate authentication

Certificates are not the only structures involved in a public key
infrastructure. Several other structures that are used for certificate
requests, encrypted private keys, revocation lists, GnuTLS abstract key
structures, etc., are discussed in this chapter.

@menu
* PKCS 10 certificate requests::
* PKIX certificate revocation lists::
* OCSP certificate status checking::
* Managing encrypted keys::
* certtool Invocation::            Invoking certtool
* ocsptool Invocation::            Invoking ocsptool
@end menu

@node PKCS 10 certificate requests
@section @acronym{PKCS} #10 certificate requests
@cindex certificate requests
@cindex PKCS #10

A certificate request is a structure, which contain information about
an applicant of a certificate service.  It usually contains a private
key, a distinguished name and secondary data such as a challenge
password. @acronym{GnuTLS} supports the requests defined in
@acronym{PKCS} #10 @xcite{RFC2986}. Other formats of certificate requests
are not currently supported.

A certificate request can be generated by
associating it with a private key, setting the
subject's information and finally self signing it.
The last step ensures that the requester is in
possession of the private key.

@showfuncE{gnutls_x509_crq_set_version,gnutls_x509_crq_set_dn_by_oid,gnutls_x509_crq_set_key_usage,gnutls_x509_crq_set_key_purpose_oid,gnutls_x509_crq_set_basic_constraints}

The @funcref{gnutls_x509_crq_set_key} and @funcref{gnutls_x509_crq_sign2} 
functions associate the request with a private key and sign it. If a 
request is to be signed with a key residing in a PKCS #11 token it is recommended to use
the signing functions shown in @ref{Abstract key types}.

@showfuncdesc{gnutls_x509_crq_set_key}
@showfuncdesc{gnutls_x509_crq_sign2}

The following example is about generating a certificate request, and a
private key. A certificate request can be later be processed by a CA
which should return a signed certificate.

@anchor{ex:crq}
@verbatiminclude examples/ex-crq.c

@node PKIX certificate revocation lists
@section PKIX certificate revocation lists
@cindex certificate revocation lists
@cindex CRL

A certificate revocation list (CRL) is a structure issued by an authority
periodically containing a list of revoked certificates serial numbers. 
The CRL structure is signed with the issuing authorities' keys. A typical
CRL contains the fields as shown in @ref{tab:crl}.
Certificate revocation lists are used to complement the expiration date of a certificate,
in order to account for other reasons of revocation, such as compromised keys, etc.

A certificate request can be generated by
associating it with a private key, setting the
subject's information and finally self signing it.
The last step ensures that the requester is in
possession of the private key. Each CRL is valid for limited amount of
time and is required to provide, except for the current issuing time, also 
the issuing time of the next update.

@float Table,tab:crl
@multitable @columnfractions .2 .7

@headitem Field @tab Description

@item version @tab
The field that indicates the version of the CRL structure.

@item signature @tab
A signature by the issuing authority.

@item issuer @tab
Holds the issuer's distinguished name.

@item thisUpdate @tab
The issuing time of the revocation list.

@item nextUpdate @tab
The issuing time of the revocation list that will update that one.

@item revokedCertificates @tab
List of revoked certificates serial numbers.

@item extensions @tab
Optional CRL structure extensions.

@end multitable
@caption{Certificate revocation list fields.}
@end float


@showfuncE{gnutls_x509_crl_set_version,gnutls_x509_crl_set_crt_serial,gnutls_x509_crl_set_crt,gnutls_x509_crl_set_next_update,gnutls_x509_crl_set_this_update}

The @funcref{gnutls_x509_crl_sign2} and @funcref{gnutls_x509_crl_privkey_sign} 
functions sign the revocation list with a private key. The latter function
can be used to sign with a key residing in a PKCS #11 token.

@showfuncdesc{gnutls_x509_crl_sign2}
@showfuncdesc{gnutls_x509_crl_privkey_sign}

Few extensions on the CRL structure are supported, including the
CRL number extension and the authority key identifier.

@showfuncB{gnutls_x509_crl_set_number,gnutls_x509_crl_set_authority_key_id}

@node OCSP certificate status checking
@section @acronym{OCSP} certificate status checking
@cindex certificate status
@cindex Online Certificate Status Protocol
@cindex OCSP

Certificates may be revoked before their expiration time has been
reached.  There are several reasons for revoking certificates, but a
typical situation is when the private key associated with a
certificate has been compromised.  Traditionally, Certificate
Revocation Lists (CRLs) have been used by application to implement
revocation checking, however, several problems with CRLs have been
identified @xcite{RIVESTCRL}.

The Online Certificate Status Protocol, or @acronym{OCSP} @xcite{RFC2560}, 
is a widely implemented protocol to perform certificate revocation status
checking.  An application that wish to verify the
identity of a peer will verify the certificate against a set of
trusted certificates and then check whether the certificate is listed
in a CRL and/or perform an OCSP check for the certificate.

Before performing the OCSP query, the application will need to figure
out the address of the OCSP server.  The OCSP server address can be
provided by the local user in manual configuration or may be stored
in the certificate that is being checked.  The latter is due to
an extension field called the Authority Information Access (AIA) which
may hold the location of the OCSP responder in 
the access method called @code{id-ad-ocsp}. The following function
extracts this information from a certificate.

@showfuncA{gnutls_x509_crt_get_authority_info_access}

There are several functions in GnuTLS for creating and manipulating
OCSP requests and responses.  The general idea is that a client
application create an OCSP request object, store some information
about the certificate to check in the request, and then export the
request in DER format.  The request will then need to be sent to the
OCSP responder, which needs to be done by the application (GnuTLS does
not send and receive OCSP packets).  Normally an OCSP response is
received that the application will need to import into an OCSP
response object.  The digital signature in the OCSP response needs to
be verified against a set of trust anchors before the information in
the response can be trusted.

The ASN.1 structure of OCSP requests are briefly as follows.  It is
useful to review the structures to get an understanding of which
fields are modified by GnuTLS functions.

@example
OCSPRequest     ::=     SEQUENCE @{
    tbsRequest                  TBSRequest,
    optionalSignature   [0]     EXPLICIT Signature OPTIONAL @}

TBSRequest      ::=     SEQUENCE @{
    version             [0]     EXPLICIT Version DEFAULT v1,
    requestorName       [1]     EXPLICIT GeneralName OPTIONAL,
    requestList                 SEQUENCE OF Request,
    requestExtensions   [2]     EXPLICIT Extensions OPTIONAL @}

Request         ::=     SEQUENCE @{
    reqCert                     CertID,
    singleRequestExtensions     [0] EXPLICIT Extensions OPTIONAL @}

CertID          ::=     SEQUENCE @{
    hashAlgorithm       AlgorithmIdentifier,
    issuerNameHash      OCTET STRING, -- Hash of Issuer's DN
    issuerKeyHash       OCTET STRING, -- Hash of Issuers public key
    serialNumber        CertificateSerialNumber @}
@end example

The basic functions to initialize, import, export and deallocate OCSP
requests are the following.

@showfuncE{gnutls_ocsp_req_init,gnutls_ocsp_req_deinit,gnutls_ocsp_req_import,gnutls_ocsp_req_export,gnutls_ocsp_req_print}

There are two interfaces for setting the identity of a certificate in
a OCSP request, the first being a low-level function when you have the
issuer name hash, issuer key hash, and certificate serial number in
binary form.  The second is usually more useful if you have the
certificate (and its issuer) in a @code{gnutls_x509_crt_t} type.
There is also a function to extract this information from an OCSP
request.

@showfuncC{gnutls_ocsp_req_add_cert_id,gnutls_ocsp_req_add_cert,gnutls_ocsp_req_get_cert_id}

Each OCSP request may contain a number of extensions.  Extensions are
identified by an Object Identifier (OID) and an opaque data buffer
whose syntax and semantics is implied by the OID.

@showfuncB{gnutls_ocsp_req_get_extension,gnutls_ocsp_req_set_extension}

A common OCSP Request extension is the nonce extension (OID
1.3.6.1.5.5.7.48.1.2), which is used to avoid replay attacks of
earlier recorded OCSP responses.  The nonce extension carries a value
that is intended to be sufficiently random and unique so that an
attacker will not be able to give a stale response for the same nonce.

@showfuncC{gnutls_ocsp_req_get_nonce,gnutls_ocsp_req_set_nonce,gnutls_ocsp_req_randomize_nonce}

The OCSP response structures is a bit more complex than the request.
The important ASN.1 structure is as follows.  In practice, all OCSP
responses contain a Basic OCSP response sub-structure.

@example
OCSPResponse ::= SEQUENCE @{
   responseStatus         OCSPResponseStatus,
   responseBytes          [0] EXPLICIT ResponseBytes OPTIONAL @}

OCSPResponseStatus ::= ENUMERATED @{
    successful            (0),  --Response has valid confirmations
    malformedRequest      (1),  --Illegal confirmation request
    internalError         (2),  --Internal error in issuer
    tryLater              (3),  --Try again later
                                --(4) is not used
    sigRequired           (5),  --Must sign the request
    unauthorized          (6)   --Request unauthorized @}

ResponseBytes ::=       SEQUENCE @{
    responseType   OBJECT IDENTIFIER,
    response       OCTET STRING @}

id-pkix-ocsp-basic     OBJECT IDENTIFIER ::= @{ id-pkix-ocsp 1 @}

BasicOCSPResponse       ::= SEQUENCE @{
   tbsResponseData      ResponseData,
   signatureAlgorithm   AlgorithmIdentifier,
   signature            BIT STRING,
   certs                [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL @}

ResponseData ::= SEQUENCE @{
   version              [0] EXPLICIT Version DEFAULT v1,
   responderID              ResponderID,
   producedAt               GeneralizedTime,
   responses                SEQUENCE OF SingleResponse,
   responseExtensions   [1] EXPLICIT Extensions OPTIONAL @}

ResponderID ::= CHOICE @{
   byName               [1] Name,
   byKey                [2] KeyHash @}

KeyHash ::= OCTET STRING -- SHA-1 hash of responder's public key
(excluding the tag and length fields)

SingleResponse ::= SEQUENCE @{
   certID                       CertID,
   certStatus                   CertStatus,
   thisUpdate                   GeneralizedTime,
   nextUpdate         [0]       EXPLICIT GeneralizedTime OPTIONAL,
   singleExtensions   [1]       EXPLICIT Extensions OPTIONAL @}

CertStatus ::= CHOICE @{
    good        [0]     IMPLICIT NULL,
    revoked     [1]     IMPLICIT RevokedInfo,
    unknown     [2]     IMPLICIT UnknownInfo @}

RevokedInfo ::= SEQUENCE @{
    revocationTime              GeneralizedTime,
    revocationReason    [0]     EXPLICIT CRLReason OPTIONAL @}
@end example

We provide basic functions for initialization, importing, exporting
and deallocating OCSP responses.  The Basic OCSP Response structure is
automatically parsed when an OCSP Response is imported.

@showfuncE{gnutls_ocsp_resp_init,gnutls_ocsp_resp_deinit,gnutls_ocsp_resp_import,gnutls_ocsp_resp_export,gnutls_ocsp_resp_print}

The OCSP response needs to be verified against some set of trust
anchors before it can be relied upon, and it is wise to check whether
the OCSP response corresponds to the certificate being checked.

@showfuncC{gnutls_ocsp_resp_verify,gnutls_ocsp_resp_verify_direct,gnutls_ocsp_resp_check_crt}

@node Managing encrypted keys
@section Managing encrypted keys
@cindex Encrypted keys

Transferring or storing private keys in plain might not be a
good idea. Any access on the keys becomes a fatal compromise.
Storing the keys in hardware security modules (see @ref{Smart cards and HSMs})
could solve the storage problem but it is not always practical
or efficient enough. This section describes alternative ways
that involve encryption of the private keys to store and
transfer.

There are two alternatives to use for key encryption, 
PKCS #8 and #12 methods of private key encryption. The PKCS #8
method only allows encryption of the private key, whilst the
PKCS #12 method allows in addition the bundling of other
data into the structure. That could be bundling together the
certificate as well as the trusted CA certificate.

@subheading @acronym{PKCS} #8 structures
@cindex PKCS #8

PKCS #8 keys can be imported and exported as normal private keys using
the functions below. An addition to the normal import functions, are
a password and a flags argument. The flags can be any element of the @code{gnutls_pkcs_encrypt_flags_t}
enumeration. Note however, that GnuTLS only supports the PKCS #5 PBES2
encryption scheme. Keys encrypted with the obsolete PBES1 scheme cannot 
be decrypted.

@showfuncB{gnutls_x509_privkey_import_pkcs8,gnutls_x509_privkey_export_pkcs8}

@showenumdesc{gnutls_pkcs_encrypt_flags_t,Encryption flags}

@subheading @acronym{PKCS} #12 structures
@cindex PKCS #12

A @acronym{PKCS} #12 structure @xcite{PKCS12} usually contains a user's
private keys and certificates. It is commonly used in browsers to
export and import the user's identities.

In @acronym{GnuTLS} the @acronym{PKCS} #12 structures are handled
using the @code{gnutls_pkcs12_t} type. This is an abstract type that
may hold several @code{gnutls_pkcs12_bag_t} types.  The bag types are
the holders of the actual data, which may be certificates, private
keys or encrypted data.  A bag of type encrypted should be decrypted
in order for its data to be accessed.

To reduce the complexity in parsing the structures the simple 
helper function @funcref{gnutls_pkcs12_simple_parse} is provided. For more
advanced uses, manual parsing of the structure is required using the
functions below.

@showfuncdesc{gnutls_pkcs12_simple_parse}

@showfuncC{gnutls_pkcs12_get_bag,gnutls_pkcs12_verify_mac,gnutls_pkcs12_bag_decrypt}

@showfuncD{gnutls_pkcs12_bag_get_count,gnutls_pkcs12_bag_get_data,gnutls_pkcs12_bag_get_key_id,gnutls_pkcs12_bag_get_friendly_name}

The functions below are used to generate a PKCS #12 structure. An example
of their usage is also shown.

@showfuncC{gnutls_pkcs12_set_bag,gnutls_pkcs12_bag_encrypt,gnutls_pkcs12_generate_mac}
@showfuncE{gnutls_pkcs12_bag_set_data,gnutls_pkcs12_bag_set_crl,gnutls_pkcs12_bag_set_crt,gnutls_pkcs12_bag_set_key_id,gnutls_pkcs12_bag_set_friendly_name}

@verbatiminclude examples/ex-pkcs12.c

@subheading Other structures
@cindex OpenSSL encrypted keys
Unfortunately the structures discussed in the previous sections are
not the only structures that may hold an encrypted private key. For example
the OpenSSL library offers a custom key encryption method. Those structures
are also supported in GnuTLS with @funcref{gnutls_x509_privkey_import_openssl}.

@showfuncdesc{gnutls_x509_privkey_import_openssl}

Generic and higher level private key import functions are also available.
@showfuncB{gnutls_x509_privkey_import2,gnutls_privkey_import_x509_raw}

@include invoke-certtool.texi

@include invoke-ocsptool.texi

